%% Import data from spreadsheet
% Script for importing data from the following spreadsheet:
%
%    Workbook: /Users/wem3/Projects/zap/excel/zapData.xlsx 
%    Worksheets: zap
%
% To extend the code to different selected data or a different spreadsheet,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2012/05/13 15:37:16

%% Import the data from 'zap', make a structure called zap

[~,~, raw] = xlsread('/Users/wem3/Projects/zap/excel/zapStimuli.xlsx','zap'); % get the path & worksheet, set the sheet to zap
%#~# change above to take user input #~#WEM3
pairHead = raw(1,:);    % set fieldnames
pairData = raw(2:end,:);       % set data 
zap = cell2struct(pairData,pairHead,2); % create structure 'zap'
clear pairHead pairData raw % clean up

%% Turn the strings in state.value into bmpz, (then RGBA matrices)

mglTextSet('Helvetica',40,[1 1 1 1],0,0,0,0,0,0,0); % set the text parameters

slice = cell(2,(length(zap)));  % a cell to hold the [100 x 900] for each value
pizza = cell(2,(length(zap)));  % a cell to hold the RGBA bit-maps for each value (cuz there's lots o' slices in a za)

for bmp = 1:length(zap);  % loop over all 124 values

        [discard1 temp1] = mglText(zap(bmp).valueA(1,(1:48)));   % split the strings in half, make a texture matrix for the top
        [discard2 temp2] = mglText(zap(bmp).valueA(1,(49:96)));  % and the bottom
        zCol = ceil(size(temp1,2) - size(temp2,2));             %
        zRow = size(temp2,1);                                   %   the code here pads the bottom to be compatible with the top,
        temp3 = horzcat(temp2,zeros(zRow,zCol));                %   and then stacks the two together (so it's just one [100,900]
        twoVal = vertcat(temp3,temp1);                          %   matrix w/ greyscale values representing our string)
        clear zRow zCol
        zCol = ceil((900 - length(twoVal))/2);
        zRow = ceil((100 - size(twoVal,1))/2);
        padsize = [zRow,zCol];
        pad = padarray(twoVal,padsize);
        pad = pad(1:100,1:900);
        slice{1,bmp} = pad;                                       % end text matrix padding portion of the loop
        clear discard1 discard2 zCol zRow temp1 temp2 temp3 twoVal pad padsize twoVal
        [discard1 temp1] = mglText(zap(bmp).valueB(1,(1:48)));   % split the strings in half, make a texture matrix for the top
        [discard2 temp2] = mglText(zap(bmp).valueB(1,(49:96)));  % and the bottom
        zCol = ceil(size(temp1,2) - size(temp2,2));             %
        zRow = size(temp2,1);                                   %   the code here pads the bottom to be compatible with the top,
        temp3 = horzcat(temp2,zeros(zRow,zCol));                %   and then stacks the two together (so it's just one [100,900]
        twoVal = vertcat(temp3,temp1);                          %   matrix w/ greyscale values representing our string)
        clear zRow zCol
        zCol = ceil((900 - length(twoVal))/2);
        zRow = ceil((100 - size(twoVal,1))/2);
        padsize = [zRow,zCol];
        pad = padarray(twoVal,padsize);
        pad = pad(1:100,1:900);
        slice{2,bmp} = pad;                                       % end text matrix padding portion of the loop
        clear discard1 discard2 zCol zRow temp1 temp2 temp3 twoVal pad padsize twoVal
        
        pizza{1,bmp} = cat(3,slice{1,bmp},slice{1,bmp},slice{1,bmp},slice{1,bmp}); % stack 4 slices (one each for red, green, blue, and alpha)
        pizza{2,bmp} = cat(3,slice{2,bmp},slice{2,bmp},slice{2,bmp},slice{2,bmp});
        zap(bmp).bmpA = pizza{1,bmp};
        zap(bmp).bmpB = pizza{2,bmp};
        
end

clear pizza bmp slice
